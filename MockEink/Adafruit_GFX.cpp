#include "Adafruit_GFX.h"

// The constructor is a common source of linker errors.
// It needs an implementation even if it does nothing.
Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h) :
    WIDTH(w), HEIGHT(h)
{
    _width = WIDTH;
    _height = HEIGHT;
    rotation = 0;
    cursor_y = cursor_x = 0;
    textsize_x = textsize_y = 1;
    textcolor = textbgcolor = 0xFFFF;
    wrap = true;
    _cp437 = false;
    gfxFont = NULL;
}

// All of these functions are "virtual" methods in the header.
// They need an implementation here to satisfy the linker.

void Adafruit_GFX::startWrite() {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::writePixel(int16_t x, int16_t y, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::writeFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::writeFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::endWrite() {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::setRotation(uint8_t x) {
    rotation = x % 4;
}

void Adafruit_GFX::invertDisplay(bool i) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
    // Bresenham's line algorithm
    int16_t dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    int16_t dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int16_t err = dx + dy, e2;

    while (true) {
        drawPixel(x0, y0, color);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
    }
}

// New stubs from your latest error list
void Adafruit_GFX::setTextSize(uint8_t s) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::fillScreen(uint16_t color) {
    // Empty stub to satisfy the linker.
}

void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    // Empty stub to satisfy the linker.
}

// This is a minimal font header, you would typically include a full one.
// The font data is usually an array of bytes.
// You would also need a drawPixel function in your MockEpaperDisplay class.
#include <stdint.h>

const uint8_t glcdfont[] = {
  0x00,0x00,0x00,0x00,0x00, // ' '
  0x00,0x00,0x5F,0x00,0x00, // '!'
  0x00,0x07,0x00,0x07,0x00, // '"'
  0x14,0x7F,0x14,0x7F,0x14, // '#'
  0x24,0x2A,0x7F,0x2A,0x12, // '$'
  0x23,0x13,0x08,0x64,0x62, // '%'
  0x36,0x49,0x55,0x22,0x50, // '&'
  0x00,0x05,0x03,0x00,0x00, // '''
  0x00,0x1C,0x22,0x41,0x00, // '('
  0x00,0x41,0x22,0x1C,0x00, // ')'
  0x14,0x08,0x3E,0x08,0x14, // '*'
  0x08,0x08,0x3E,0x08,0x08, // '+'
  0x00,0x50,0x30,0x00,0x00, // ','
  0x08,0x08,0x08,0x08,0x08, // '-'
  0x00,0x60,0x60,0x00,0x00, // '.'
  0x20,0x10,0x08,0x04,0x02, // '/'
  0x3E,0x51,0x49,0x45,0x3E, // '0'
  0x00,0x42,0x7F,0x40,0x00, // '1'
  0x72,0x49,0x49,0x49,0x46, // '2'
  0x21,0x41,0x49,0x4D,0x33, // '3'
  0x18,0x14,0x12,0x7F,0x10, // '4'
  0x27,0x45,0x45,0x45,0x39, // '5'
  0x3C,0x4A,0x49,0x49,0x31, // '6'
  0x41,0x21,0x11,0x09,0x07, // '7'
  0x36,0x49,0x49,0x49,0x36, // '8'
  0x46,0x49,0x49,0x29,0x1E, // '9'
  0x00,0x36,0x36,0x00,0x00, // ':'
  0x00,0x56,0x36,0x00,0x00, // ';'
  0x08,0x14,0x22,0x41,0x00, // '<'
  0x14,0x14,0x14,0x14,0x14, // '='
  0x00,0x41,0x22,0x14,0x08, // '>'
  0x02,0x01,0x59,0x09,0x06, // '?'
  0x3E,0x41,0x5D,0x59,0x4E, // '@'
  0x7C,0x12,0x11,0x12,0x7C, // 'A'
  0x7F,0x49,0x49,0x49,0x36, // 'B'
  0x3E,0x41,0x41,0x41,0x22, // 'C'
  0x7F,0x41,0x41,0x22,0x1C, // 'D'
  0x7F,0x49,0x49,0x49,0x41, // 'E'
  0x7F,0x09,0x09,0x09,0x01, // 'F'
  0x3E,0x41,0x49,0x49,0x7A, // 'G'
  0x7F,0x08,0x08,0x08,0x7F, // 'H'
  0x00,0x41,0x7F,0x41,0x00, // 'I'
  0x20,0x40,0x41,0x3F,0x01, // 'J'
  0x7F,0x08,0x14,0x22,0x41, // 'K'
  0x7F,0x40,0x40,0x40,0x40, // 'L'
  0x7F,0x02,0x0C,0x02,0x7F, // 'M'
  0x7F,0x04,0x08,0x10,0x7F, // 'N'
  0x3E,0x41,0x41,0x41,0x3E, // 'O'
  0x7F,0x09,0x09,0x09,0x06, // 'P'
  0x3E,0x41,0x51,0x21,0x5E, // 'Q'
  0x7F,0x09,0x19,0x29,0x46, // 'R'
  0x46,0x49,0x49,0x49,0x31, // 'S'
  0x01,0x01,0x7F,0x01,0x01, // 'T'
  0x3F,0x40,0x40,0x40,0x3F, // 'U'
  0x1F,0x20,0x40,0x20,0x1F, // 'V'
  0x3F,0x40,0x38,0x40,0x3F, // 'W'
  0x63,0x14,0x08,0x14,0x63, // 'X'
  0x07,0x08,0x70,0x08,0x07, // 'Y'
  0x61,0x51,0x49,0x45,0x43, // 'Z'
  0x00,0x7F,0x41,0x41,0x00, // '['
  0x02,0x04,0x08,0x10,0x20, // '\'
  0x00,0x41,0x41,0x7F,0x00, // ']'
  0x04,0x02,0x01,0x02,0x04, // '^'
  0x40,0x40,0x40,0x40,0x40, // '_'
  0x00,0x01,0x02,0x04,0x00, // '`'
  0x20,0x54,0x54,0x54,0x78, // 'a'
  0x7F,0x48,0x44,0x44,0x38, // 'b'
  0x38,0x44,0x44,0x44,0x20, // 'c'
  0x38,0x44,0x44,0x48,0x7F, // 'd'
  0x38,0x54,0x54,0x54,0x18, // 'e'
  0x08,0x7E,0x09,0x01,0x02, // 'f'
  0x0C,0x52,0x52,0x52,0x3E, // 'g'
  0x7F,0x08,0x04,0x04,0x78, // 'h'
  0x00,0x44,0x7D,0x40,0x00, // 'i'
  0x20,0x40,0x44,0x3D,0x00, // 'j'
  0x7F,0x10,0x28,0x44,0x00, // 'k'
  0x00,0x41,0x7F,0x40,0x00, // 'l'
  0x7C,0x04,0x18,0x04,0x78, // 'm'
  0x7C,0x08,0x04,0x04,0x78, // 'n'
  0x38,0x44,0x44,0x44,0x38, // 'o'
  0x7C,0x14,0x14,0x14,0x08, // 'p'
  0x08,0x14,0x14,0x18,0x7C, // 'q'
  0x7C,0x08,0x04,0x04,0x08, // 'r'
  0x48,0x54,0x54,0x54,0x20, // 's'
  0x04,0x3F,0x44,0x40,0x20, // 't'
  0x3C,0x40,0x40,0x20,0x7C, // 'u'
  0x1C,0x20,0x40,0x20,0x1C, // 'v'
  0x3C,0x40,0x30,0x40,0x3C, // 'w'
  0x44,0x28,0x10,0x28,0x44, // 'x'
  0x0C,0x50,0x50,0x50,0x3C, // 'y'
  0x44,0x64,0x54,0x4C,0x44, // 'z'
  0x00,0x08,0x36,0x41,0x00, // '{'
  0x00,0x00,0x7F,0x00,0x00, // '|'
  0x00,0x41,0x36,0x08,0x00, // '}'
  0x10,0x08,0x08,0x10,0x08  // '~'
};
size_t Adafruit_GFX::write(uint8_t c) {
    if (!gfxFont) { // Using standard 5x7 pixel font
        if (c == '\n') { // Newline character
            cursor_x = 0;
            cursor_y += textsize_y * 8;
        } else if (c == '\r') { // Carriage return
            // Ignore for now, standard behavior is a new line
        } else {
            // Check if the character is within the supported ASCII range (32 to 126)
            if (c < 32 || c > 126) {
                // Return 0 if the character is not supported
                return 0;
            }

            // Check if there is space on the display
            if (cursor_x > _width - textsize_x * 6) {
                // Wrap to a new line
                cursor_x = 0;
                cursor_y += textsize_y * 8;
            }

            // Check if we are past the bottom of the display
            if (cursor_y > _height - textsize_y * 8) {
                return 0; // Don't write off-screen
            }

            // Define the background color for character spacing.
            uint16_t bgcolor = 0; // Black background for spacing

            // Iterate over each of the 5 columns of the character
            for (int8_t i = 0; i < 5; i++ ) {
                // Get the byte representing the column from the font data.
                // Subtract 32 from the character's ASCII value to get the correct index.
                uint8_t line = glcdfont[(c - 32) * 5 + i];

                // Iterate over each row (pixel) in the column
                for (int8_t j = 0; j < 8; j++, line >>= 1) {
                    // Check if the pixel should be drawn
                    if (line & 0x1) {
                        // Draw the pixel at the calculated coordinates
                        drawPixel(cursor_x + i * textsize_x, cursor_y + j * textsize_y, textcolor);
                    }
                }
            }

            // Draw a single blank column for spacing between characters
            drawPixel(cursor_x + 5 * textsize_x, cursor_y, bgcolor);

            // Advance the cursor position
            cursor_x += textsize_x * 6;
        }
    }
    return 1; // Return 1 to indicate that one character was successfully "written"
}
